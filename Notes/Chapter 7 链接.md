# Chapter 7 Linking读书笔记

## 知识梗概：

1. 链接器的主要功能：符号解析(Symbol Resolution)和重定位(Relocation)。
    - 符号解析：链接器将目标文件中的每一个符号引用(Symbol Reference)同确定的一个符号定义相关联起来。
      1) 对局部符号的解析
      2) 对全局符号的解析，尤其是对多重定义的全局符号的选择(强弱符号、三条规则)
    - 重定位：确定符号定义的运行时内存地址，重定位各个节，修改相应的符号引用。
      1）合并各个目标文件中的节到新的可执行目标文件中
      2）重定位符号定义
      3）修改符号引用
2. 链接可以发生在编译时(compile time)、加载时(load time)、运行时(run time)，使用链接器与静态链接库实现编译时的静态链接，使用动态链接器与动态链接库完成加载时和运行时的动态链接。
    - 静态链接库：存档(Archive文件或者成为.a文件，一组连接起来的可重定位目标文件的集合，包含头部描述各个成员目标文件的大小和位置。
      如何生成.a文件
      链接器如何解析静态链接库： 算法 
    - 动态链接库：共享目标文件，.so文件。对于加载时链接：编译时部分链接，加载时加载器调用动态链接器，动态链接器完成完全链接；对于运行时链接：编译时无需链接，使用接口`void *dlopen(const char*, int flag)`，`void *dlsym(void *handle, char *symbol)`, `int dlclose(void *handle)`加载和链接共享库，找到相应的符号。
3. 库打桩机制：Linux链接器支持库打桩机制，允许程序员截获对共享库函数的调用，取而代之执行自己的代码。
    基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一致，使用某种特殊的打桩机制，就可以欺骗系统调用包装函数而不是目标函数。
   三种机制：编译时打桩、链接时打桩和运行时打桩。
   
## 重要定义
+ 符号：强符号和弱符号

+ ELF目标文件格式：可重定位目标文件(.o)、可执行目标文件、共享目标文件(.so)
   需要完全掌握的相关概念：ELF header, segment(program) header table, .text, .data, .bss, .symtab, .rel.text, .rel.data, section header table
   其他的：.init(exec obj才有）, .debug, .line, .strtab, 三个伪节（ABS， UNDEF， COMMON， .o obj才有）
   
+ 符号表条目、重定位条目

+ 内存镜像，可执行目标文件到内存镜像的映射

+ 如何加载可执行目标文件

+ 位置无关代码（PIC），PIC数据引用的过程，全局偏移表（GOT）和过程链接表（PLT）如何相互配合实现PIC函数调用。

## 易混淆的点
1. 符号和C变量之间的对应关系，或者说C变量存放在那些节中
2. 符号解析时的算法介绍中，符号定义的偏移地址(在目标文件中)、符号引用的偏移地址、符号定义的运行时地址、符号引用的运行时地址

## 本章介绍的工具使用
objdump：所有二进制工具之母，能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制命令。
常用命令：
`objdump -dx main.o > main-relo.d`
`objdump -dx -j .text main.o > maindata-relo.d`
常用参数解释
```shell
objdump -dx [-j <section name>] obj
-d 反汇编那些有汇编指令的节
-x 显示所有节头部的内容
-r 显示重定位信息
-h 节头部信息
-t 显示符号表
-S 反汇编源代码(如.init .plt .text等)
-s 显示所有节的二进制内容
```
readelf：显示目标文件中完整的结构，可以显示ELF头中的所有信息等
常用命令：
```shell
readelf -a obj 
-a 显示目标文件中所有的信息
```
GNU提供的其他处理目标文件的工具
`ar rcs libvector.a addvec.o multvec.o`




